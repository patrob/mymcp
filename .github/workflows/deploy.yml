name: Production Deployment

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
  workflow_dispatch:
    inputs:
      skip_infrastructure:
        description: "Skip infrastructure deployment"
        required: false
        default: false
        type: boolean
      droplet_ip:
        description: "Droplet IP address (leave empty to use from infrastructure)"
        required: false
        type: string

permissions:
  contents: read
  security-events: write

env:
  DOTNET_VERSION: "9.0.x"
  NODE_VERSION: "22"

jobs:
  # Security Analysis Jobs (Parallel)
  codeql-analysis:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: ["csharp", "typescript"]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          config-file: ./.github/codeql/codeql-config.yml

      # For C# analysis
      - name: Setup .NET
        if: matrix.language == 'csharp'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Cache NuGet packages
        if: matrix.language == 'csharp'
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('Directory.Packages.props') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Build .NET solution
        if: matrix.language == 'csharp'
        run: |
          dotnet restore
          dotnet build --no-restore --configuration Release

      # For TypeScript analysis
      - name: Setup Node.js
        if: matrix.language == 'typescript'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: "./OnParDev.MyMcp.Api/ClientApp/package-lock.json"

      - name: Install frontend dependencies
        if: matrix.language == 'typescript'
        run: |
          cd OnParDev.MyMcp.Api/ClientApp
          npm ci

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{matrix.language}}"

  dependency-scanning:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: "./OnParDev.MyMcp.Api/ClientApp/package-lock.json"

      - name: Install .NET dependencies
        run: dotnet restore

      - name: Install npm dependencies
        run: |
          cd OnParDev.MyMcp.Api/ClientApp
          npm ci

      - name: Run .NET vulnerability scan
        run: dotnet list package --vulnerable --include-transitive

      - name: Run npm audit
        run: |
          cd OnParDev.MyMcp.Api/ClientApp
          npm audit --audit-level=moderate || echo "npm audit found vulnerabilities in dev dependencies - non-blocking"
        continue-on-error: true

  # Build and Test Jobs (Parallel, depends on security)
  frontend-build-test:
    name: Frontend Build & Test
    runs-on: ubuntu-latest
    needs: [codeql-analysis, dependency-scanning]
    defaults:
      run:
        working-directory: ./OnParDev.MyMcp.Api/ClientApp

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET (for API generation)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: "./OnParDev.MyMcp.Api/ClientApp/package-lock.json"

      - name: Install .NET dependencies
        run: dotnet restore
        working-directory: ./

      - name: Start API for OpenAPI generation
        run: |
          dotnet build --configuration Release
          nohup dotnet run --project OnParDev.MyMcp.Api --configuration Release &
          sleep 30
        working-directory: ./
        env:
          CLERK__PUBLISHABLEKEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          CLERK__AUTHORITY: ${{ secrets.CLERK_AUTHORITY }}

      - name: Install frontend dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run TypeScript check
        run: npx tsc --noEmit

      - name: Run Vitest tests
        run: npm test

      - name: Generate API client
        run: npm run generate-api

      - name: Build frontend
        run: npm run build

      - name: Upload frontend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-prod
          path: ./OnParDev.MyMcp.Api/ClientApp/dist/
          retention-days: 90

  backend-build-test:
    name: Backend Build & Test
    runs-on: ubuntu-latest
    needs: [codeql-analysis, dependency-scanning]

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: onpardev_mymcp_test
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('Directory.Packages.props') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore dependencies
        run: dotnet restore

      - name: Build solution
        run: dotnet build --no-restore --configuration Release

      - name: Run unit tests
        run: dotnet test OnParDev.MyMcp.Api.UnitTests --no-build --configuration Release --verbosity normal --logger trx --results-directory TestResults/

      - name: Run integration tests
        run: dotnet test OnParDev.MyMcp.Api.IntegrationTests --no-build --configuration Release --verbosity normal --logger trx --results-directory TestResults/
        env:
          ConnectionStrings__DefaultConnection: "Host=localhost;Database=onpardev_mymcp_test;Username=postgres;Password=postgres"
          CLERK__PUBLISHABLEKEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          CLERK__AUTHORITY: ${{ secrets.CLERK_AUTHORITY }}

      - name: Publish API
        run: dotnet publish OnParDev.MyMcp.Api --configuration Release --output ./publish-api -p:SkipFrontendBuild=true

      - name: Upload API build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: api-build-prod
          path: ./publish-api/
          retention-days: 90

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-prod
          path: TestResults/
          retention-days: 30

  # Infrastructure Deployment
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [frontend-build-test, backend-build-test]
    if: github.event.inputs.skip_infrastructure != 'true'
    environment: production

    defaults:
      run:
        working-directory: infrastructure

    outputs:
      droplet_ip: ${{ steps.outputs.outputs.droplet_ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ~1.0

      - name: Terraform Init
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
          SPACES_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          SPACES_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
        run: terraform init


      - name: Terraform Plan
        id: plan
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
          SPACES_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          SPACES_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
          TF_VAR_digitalocean_token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
          SPACES_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          SPACES_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
          TF_VAR_digitalocean_token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
        run: terraform apply -auto-approve tfplan

      - name: Get outputs
        id: outputs
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
          SPACES_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
          SPACES_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
        run: |
          echo "droplet_ip=$(terraform output -raw droplet_ip)" >> $GITHUB_OUTPUT
          echo "ssh_connection=$(terraform output -raw ssh_connection)" >> $GITHUB_OUTPUT

      - name: Infrastructure deployment summary
        run: |
          echo "🏗️ Infrastructure deployed successfully!" >> $GITHUB_STEP_SUMMARY
          echo "**Droplet IP:** ${{ steps.outputs.outputs.droplet_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**SSH:** ${{ steps.outputs.outputs.ssh_connection }}" >> $GITHUB_STEP_SUMMARY

  # Application Deployment
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    if: always() && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get droplet IP
        id: get-ip
        run: |
          if [ "${{ github.event.inputs.droplet_ip }}" != "" ]; then
            echo "droplet_ip=${{ github.event.inputs.droplet_ip }}" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy-infrastructure.outputs.droplet_ip }}" != "" ]; then
            echo "droplet_ip=${{ needs.deploy-infrastructure.outputs.droplet_ip }}" >> $GITHUB_OUTPUT
          else
            # Fallback: get from Terraform state
            cd infrastructure
            export AWS_ACCESS_KEY_ID="${{ secrets.SPACES_ACCESS_KEY_ID }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.SPACES_SECRET_ACCESS_KEY }}"
            export SPACES_ACCESS_KEY_ID="${{ secrets.SPACES_ACCESS_KEY_ID }}"
            export SPACES_SECRET_ACCESS_KEY="${{ secrets.SPACES_SECRET_ACCESS_KEY }}"
            export TF_VAR_digitalocean_token="${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}"
            export TF_VAR_ssh_public_key="${{ secrets.SSH_PUBLIC_KEY }}"
            terraform init
            DROPLET_IP=$(terraform output -raw droplet_ip)
            echo "droplet_ip=${DROPLET_IP}" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment files
        run: |
          cat > .env << EOF
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          CLERK_SECRET_KEY=${{ secrets.CLERK_SECRET_KEY }}
          CLERK_PUBLISHABLE_KEY=${{ secrets.CLERK_PUBLISHABLE_KEY }}
          CLERK_AUTHORITY=${{ secrets.CLERK_AUTHORITY }}
          EOF

      - name: Wait for droplet readiness
        run: |
          echo "⏳ Waiting for droplet to be ready..."
          for i in {1..10}; do
            if nc -z -w5 ${{ steps.get-ip.outputs.droplet_ip }} 22; then
              echo "✅ SSH port is open"
              # Give cloud-init extra time to complete user setup
              echo "⏳ Waiting additional 2 minutes for cloud-init to complete user setup..."
              sleep 120
              break
            else
              echo "⏳ Waiting for SSH to be available... (attempt $i/10)"
              sleep 30
            fi
            if [ $i -eq 10 ]; then
              echo "❌ SSH port never became available"
              exit 1
            fi
          done

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-ip.outputs.droplet_ip }} >> ~/.ssh/known_hosts
          
          # Debug SSH key format and validate
          echo "🔍 SSH key info:"
          file ~/.ssh/id_rsa
          head -1 ~/.ssh/id_rsa
          
          # Validate key pair
          echo "🔍 Validating SSH key pair..."
          ssh-keygen -y -f ~/.ssh/id_rsa > /tmp/derived_pubkey.pub
          echo "Public key from private key:"
          cat /tmp/derived_pubkey.pub
          echo "Expected public key:"
          echo "${{ secrets.SSH_PUBLIC_KEY }}"
          
          if [ "$(cat /tmp/derived_pubkey.pub)" = "${{ secrets.SSH_PUBLIC_KEY }}" ]; then
            echo "✅ SSH key pair is valid"
          else
            echo "❌ SSH key pair mismatch!"
            exit 1
          fi

      - name: Test SSH connectivity
        run: |
          echo "🔍 Testing SSH connectivity..."
          echo "Testing root access:"
          ssh -v -o ConnectTimeout=10 root@${{ steps.get-ip.outputs.droplet_ip }} "echo 'Root access works'" || echo "❌ Root access failed"

      - name: Copy files to server
        run: |
          # Use root user for deployment
          ssh root@${{ steps.get-ip.outputs.droplet_ip }} "mkdir -p /opt/mymcp"
          scp -r . root@${{ steps.get-ip.outputs.droplet_ip }}:/opt/mymcp/
          scp .env root@${{ steps.get-ip.outputs.droplet_ip }}:/opt/mymcp/.env

      - name: Setup Docker Environment
        run: |
          ssh root@${{ steps.get-ip.outputs.droplet_ip }} << 'EOF'
            echo "🔍 Checking Docker installation..."
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "📦 Installing Docker..."
              
              # Update packages
              apt-get update
              
              # Install Docker
              curl -fsSL https://get.docker.com -o get-docker.sh
              sh get-docker.sh
              
              # Start and enable Docker
              systemctl enable docker
              systemctl start docker
              
              echo "✅ Docker installed successfully"
            else
              echo "✅ Docker is already installed"
              systemctl start docker || true
            fi
            
            # Check if Docker Compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo "📦 Installing Docker Compose..."
              
              # Install Docker Compose
              curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
              
              echo "✅ Docker Compose installed successfully"
            else
              echo "✅ Docker Compose is already installed"
            fi
            
            # Verify installations
            echo "🔍 Verifying installations:"
            docker --version
            docker-compose --version
            
            echo "✅ Docker environment ready"
          EOF

      - name: Deploy application
        run: |
          ssh root@${{ steps.get-ip.outputs.droplet_ip }} << 'EOF'
            cd /opt/mymcp
            
            # Stop existing containers
            docker-compose -f docker-compose.production.yml down || true
            
            # Remove old images to save space on $6/month droplet
            docker image prune -f
            
            # Build and start the application
            docker-compose -f docker-compose.production.yml up -d --build
            
            # Wait for services to be healthy
            echo "Waiting for services to start..."
            sleep 30
            
            # Check if services are running
            docker-compose -f docker-compose.production.yml ps
          EOF

      - name: Deployment diagnostics
        run: |
          echo "🔍 Running comprehensive deployment diagnostics..."
          ssh root@${{ steps.get-ip.outputs.droplet_ip }} << 'EOF'
            cd /opt/mymcp
            
            echo "========================================="
            echo "📊 CONTAINER STATUS"
            echo "========================================="
            docker-compose -f docker-compose.production.yml ps -a
            echo ""
            
            echo "========================================="
            echo "🏥 CONTAINER HEALTH STATUS"
            echo "========================================="
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            
            echo "========================================="
            echo "📋 CONTAINER LOGS (Last 20 lines each)"
            echo "========================================="
            echo "--- NGINX LOGS ---"
            docker-compose -f docker-compose.production.yml logs --tail=20 nginx || echo "Nginx container not running"
            echo ""
            echo "--- APP LOGS ---"
            docker-compose -f docker-compose.production.yml logs --tail=20 app || echo "App container not running"
            echo ""
            echo "--- POSTGRES LOGS ---"
            docker-compose -f docker-compose.production.yml logs --tail=20 postgres || echo "Postgres container not running"
            echo ""
            
            echo "========================================="
            echo "🌐 NETWORK CONNECTIVITY"
            echo "========================================="
            echo "Port 80 binding:"
            netstat -tlnp | grep :80 || echo "Port 80 not bound"
            echo ""
            echo "Port 443 binding:"
            netstat -tlnp | grep :443 || echo "Port 443 not bound"
            echo ""
            
            echo "========================================="
            echo "🔧 ENVIRONMENT VARIABLES"
            echo "========================================="
            echo "Environment file exists:" 
            ls -la .env || echo ".env file not found"
            echo ""
            
            echo "========================================="
            echo "🧪 PROGRESSIVE CONNECTIVITY TESTS"
            echo "========================================="
            echo "Test 1: Basic port 80 connectivity"
            if nc -z localhost 80; then
              echo "✅ Port 80 is reachable"
            else
              echo "❌ Port 80 is not reachable"
            fi
            echo ""
            
            echo "Test 2: Nginx response"
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:80 | grep -q "200\|404\|301\|302"; then
              echo "✅ Nginx is responding"
              echo "Nginx response: $(curl -s -I http://localhost:80 | head -1)"
            else
              echo "❌ Nginx is not responding"
            fi
            echo ""
            
            echo "Test 3: Health endpoint test"
            echo "Testing: http://localhost:80/health"
            curl -v http://localhost:80/health || echo "❌ Health endpoint failed"
            echo ""
            
            echo "Test 4: App direct test (if accessible)"
            echo "Testing: http://localhost:8080/api/v1/health"
            curl -v http://localhost:8080/api/v1/health || echo "❌ Direct app health failed"
            echo ""
            
            echo "========================================="
            echo "📁 FRONTEND BUILD VERIFICATION"
            echo "========================================="
            if [ -d "/opt/mymcp/OnParDev.MyMcp.Api/wwwroot" ]; then
              echo "✅ wwwroot directory exists"
              echo "Contents:"
              ls -la /opt/mymcp/OnParDev.MyMcp.Api/wwwroot/ || echo "Cannot list wwwroot contents"
            else
              echo "❌ wwwroot directory not found"
            fi
          EOF

      - name: Health check
        run: |
          echo "🏥 Performing progressive health check..."
          
          # Test 1: Basic connectivity to port 80
          echo "Test 1/3: Testing basic port 80 connectivity..."
          for i in {1..5}; do
            if nc -z -w5 ${{ steps.get-ip.outputs.droplet_ip }} 80; then
              echo "✅ Port 80 is reachable from external"
              break
            else
              echo "⏳ Waiting for port 80 to be available... (attempt $i/5)"
              sleep 10
            fi
            if [ $i -eq 5 ]; then
              echo "❌ Port 80 never became available"
              echo "🔍 Running remote port check..."
              ssh root@${{ steps.get-ip.outputs.droplet_ip }} "netstat -tlnp | grep :80 || echo 'No process listening on port 80'"
              exit 1
            fi
          done
          
          # Test 2: Nginx response (any response)
          echo "Test 2/3: Testing nginx response..."
          for i in {1..5}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.get-ip.outputs.droplet_ip }}/ || echo "000")
            if [ "$HTTP_CODE" != "000" ]; then
              echo "✅ Nginx is responding with HTTP $HTTP_CODE"
              break
            else
              echo "⏳ Waiting for nginx to respond... (attempt $i/5)"
              sleep 10
            fi
            if [ $i -eq 5 ]; then
              echo "❌ Nginx is not responding"
              echo "🔍 Checking nginx status remotely..."
              ssh root@${{ steps.get-ip.outputs.droplet_ip }} "docker-compose -f /opt/mymcp/docker-compose.production.yml logs --tail=10 nginx"
              exit 1
            fi
          done
          
          # Test 3: Health endpoint
          echo "Test 3/3: Testing health endpoint..."
          for i in {1..10}; do
            if curl -f http://${{ steps.get-ip.outputs.droplet_ip }}/health; then
              echo "✅ Health endpoint is working!"
              echo "🎉 Application deployment successful!"
              break
            else
              echo "⏳ Waiting for health endpoint to be ready... (attempt $i/10)"
              if [ $i -eq 5 ]; then
                echo "🔍 Checking application logs for debugging..."
                ssh root@${{ steps.get-ip.outputs.droplet_ip }} "docker-compose -f /opt/mymcp/docker-compose.production.yml logs --tail=20 app"
              fi
              sleep 30
            fi
            if [ $i -eq 10 ]; then
              echo "❌ Health endpoint failed after 10 attempts"
              echo "🔍 Final diagnostic check..."
              ssh root@${{ steps.get-ip.outputs.droplet_ip }} << 'EOFSCRIPT'
                cd /opt/mymcp
                echo "Container status:"
                docker-compose -f docker-compose.production.yml ps
                echo "Recent application logs:"
                docker-compose -f docker-compose.production.yml logs --tail=30 app
                echo "Testing direct health endpoint:"
                curl -v http://localhost:8080/api/v1/health || echo "Direct health check failed"
          EOFSCRIPT
              exit 1
            fi
          done

      - name: Deployment summary
        run: |
          echo "🚀 Production deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application URL:** http://${{ steps.get-ip.outputs.droplet_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**Health Check:** http://${{ steps.get-ip.outputs.droplet_ip }}/health" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**SSH Access:** \`ssh mymcp@${{ steps.get-ip.outputs.droplet_ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Pipeline:**" >> $GITHUB_STEP_SUMMARY
          echo "✅ Security Analysis (CodeQL, Dependencies)" >> $GITHUB_STEP_SUMMARY
          echo "✅ Build & Test (Frontend + Backend)" >> $GITHUB_STEP_SUMMARY
          echo "✅ Infrastructure Deployment" >> $GITHUB_STEP_SUMMARY
          echo "✅ Application Deployment" >> $GITHUB_STEP_SUMMARY
